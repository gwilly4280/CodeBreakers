---
title: "R Notebook"
output: html_notebook
---
PART 1 OF OUR FULL SCRIPT

**Workflow**:

  1. *Subsetting the data.R*: load, subset & sample dataset 
      * Output: countries (dataframe)
      
  2. *Fasta_function.R*: initialize FASTA manipulating functions
  
  3. *spike_reference_test.R*: Load in reference spike sequence and get start/end motifs.
  
  4. *Full Data.R*: Get FASTA files, process & isolate target sequences, align sequences & flag mutations
      * Output: df_isolate (dataframe)
      
  5. *Mutation_function.R*: Initialize mutation isolation functions, load and format reference mutation data
      * Output: mutations_ref (dataframe)
  
  .
  .
  .

More to follow...

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Loading libraries
```{r, include=FALSE}
library(ape)
library(adegenet)
library(dplyr)
library(stringr)
library(readr)
library(rentrez)
```


# Importing and fixing covid sequences dataset
```{r}
# Loading Sequence data & filtering by completeness, trimming un-used cols
dat <- read.csv('./Dataset/sequences.csv') %>%
  filter(Nuc_Completeness == "complete") %>%
  transmute(Accession, Length, Geo_Location)

# Setting seed for replicability
set.seed(1)

# Setting number of samples per country:
N <- 50

# Filter dataset by country, and sampling N random samples from each
dat_USA <- dat %>%
  filter(str_detect(Geo_Location, 'USA')) %>%
  mutate(Geo_Location = "USA") %>%
  slice_sample(n = N)

dat_CHINA <- dat %>%
  filter(str_detect(Geo_Location, 'China')) %>%
  mutate(Geo_Location = "CHN") %>%
  slice_sample(n = N)

dat_AUSTRALIA <- dat %>%
  filter(str_detect(Geo_Location, 'Australia')) %>%
  mutate(Geo_Location = "AUS") %>%
  slice_sample(n = N)

dat_INDIA <- dat %>%
  filter(str_detect(Geo_Location, 'India')) %>%
  mutate(Geo_Location = "IND") %>%
  slice_sample(n = N)

dat_JAPAN <- dat %>%
  filter(str_detect(Geo_Location, 'Japan')) %>%
  mutate(Geo_Location = "JPN") %>%
  slice_sample(n = N)

# Dataset with the selected countries
countries <- rbind(dat_JAPAN, dat_INDIA, dat_AUSTRALIA, dat_CHINA, dat_USA)

# Removing the temp data files
rm(dat, N, dat_AUSTRALIA, dat_CHINA, dat_USA, dat_INDIA, dat_JAPAN)
```

# Importing data frame with the known mutations
Dataset with the known mutations and the locations. 
```{r}
mutations <- read.csv('./Dataset/mutations.csv')
SpikeStart<-21563
mutations$RelativeLocation<-mutations$Location- SpikeStart
```

# Importing FASTA file of the reference spike protein nucleotide
FASTA file of the *original* spike protein nucleotide without mutations for comparisons.
```{r}
# Loading in Fasta_functions.R file
source("./Fasta_functions.R")

####### PREPARING SPIKE TEMPLATE #######

# Setting correct filename & extension
fileName <- "./Dataset/spike_reference.txt"

# Load in the reference sequence
spike_fasta <-  readChar(fileName, file.info(fileName)$size)

# Clean FASTA file & remove sequence
spike_seq <- separate_fasta(spike_fasta)$Sequence

# Getting start & end motifs to capture our sequence of 12 bp/side
start_motif <- paste(substr(spike_seq, 1, 6), 
                     "[GT]", # to accommodate a mutation in the start motif 
                     substr(spike_seq, 8, 12), sep = "")
end_motif <- substr(spike_seq, nchar(spike_seq) - 11, nchar(spike_seq))
```

# Creating FASTA function
Takes String FASTA file as input returns dataframe w/ w/ 1 col for header, & 1 for raw sequence with each row representing a single FASTA entry from the FASTA file
```{r}
separate_fasta <- function(fasta){
   fasta <- unlist(strsplit(fasta, split = "\n\n"))
   header <- gsub("(^>.*[a-z])(\\n|\\r).*", "\\1", fasta)
   seq <- gsub("^>.*[a-z](\\n|\\r)(.*)", "\\2", fasta)
   seq <- gsub("\\n|\\r", "", seq)
   return(data.frame(Name = header, Sequence = seq))
}
```

Takes df created by *separate_fasta*, and a start seq, and end seq (as String) returns df w/ new "Target" col: sequence w/in & including start:end motifs
```{r}
isolate_seq <- function(df, start, end){
   df$Target = gsub(paste(".*(", start, ".*?",end, ").*", sep=""), "\\1", df$Sequence)
   return(df)
}
```


# Loading Spike reference test
```{r}
# Setting correct filename & extension
fileName <- "./Dataset/spike_reference.txt"

# Load in the reference sequence
spike_fasta <-  readChar(fileName, file.info(fileName)$size)

# Clean FASTA file & convert to format compatible with dataset
spike_ref <- separate_fasta(spike_fasta) %>%
  mutate(Target = Sequence,
         Sequence = "NULL",
         seq_len = nchar(Target),
         Geo_Location = "REF")

# Getting start & end motifs to capture our sequence of 12 bp/side
start_motif <- paste(substr(spike_seq, 1, 6),
                     "[GT]", # to accommodate a mutation in the start motif
                     substr(spike_seq, 8, 12), sep = "")
end_motif <- substr(spike_ref$Target,
                    nchar(spike_ref$Target) - 11,
                    nchar(spike_ref$Target))

# Removing excess variables
rm(fileName, spike_fasta)
```


# Adapting Spike reference code to work with repdf
Code added to get it to process more than 100 sequences at a time
```{r}
remain = nrow(countries)
i = 1
j = 0
Repdf_fasta = ""
while(remain > 0){
  if (remain < 100)
    diff = remain
  else
    diff = 100
  j = j + diff
  Repdf_fasta <- paste(Repdf_fasta, entrez_fetch(db = "nuccore",
                                                 id = countries[i:j,]$Accession,
                                                 rettype = "fasta"), sep = "")
  i = i + diff
  remain = remain - diff
}

# Removing temp variables
rm(diff, i, j, remain)

## For the new df
# Cleaning FASTA
df_clean <- separate_fasta(Repdf_fasta)

# Isolating based on start & End motifs
df_isolate <- isolate_seq(df_clean, start_motif, end_motif)

# Checking length of each sequence
df_isolate <- df_isolate %>%
  mutate(seq_len = nchar(Target))

df_isolate <- rbind(spike_ref, cbind(df_isolate,Geo_Location = countries$Geo_Location))

N = nrow(df_isolate)
```


# Mutations
```{r}
#To obtain the sequence we use the sapply function
isolatedseq<-sapply(df_isolate$Target,strsplit,split="")

#Names and data formatted as DNAbin
names(isolatedseq)<-paste(1:nrow(df_isolate),df_isolate$Name,sep="_")
isolatedseq<-as.DNAbin(isolatedseq)

#Aligning sequences
seqalign<-muscle(isolatedseq,quiet=F)

#
checkAlignment(seqalign[1:N,1:3822])
aligned<-as.alignment(seqalign[1:N,1:3822])
aligned<-as.DNAbin(aligned)
muts<-findMutations(aligned[1:N,],from = 1)

#Gross Regex
mut<-lapply(muts, "[",  "short")
mutchar<- lapply(mut, as.character)
mutchar<-gsub("[()=]","",mutchar)
mutchar<-sub("\\w+?","",mutchar)
mutations<- c("Reference",mutchar)
df_isolate$Mutations <- mutations

# Removing extra variables
rm(df_clean, isolatedseq, seqalign, aligned, muts, mut, mutchar, mutations, Repdf_fasta)
```


Find mutation accessions in reference, and add to df_isolate:
```{r}
########### Work with the reference mutations ###########

# Load mutation file
mutations <- read.csv("./Dataset/mutations.csv")

# Function for extracting usable mutations from the reference mutation dataset
extract_mut <- function(raw_muts, pos){
  muts <- strsplit(raw_muts, split = " > ")[[1]]
  origin <- strsplit(muts, split = "")[[2]] # flipped here to be compatible with our dataset
  new <- strsplit(muts, split = "")[[1]]
  for (i in c(1:3)){
    if (!grepl(origin[i], new[i])){
      return(paste((pos - 21562), ":" , tolower(origin[i]), "->", tolower(new[i]), sep=""))
    }
  }
}


# Dyplr code to convert the mutations into something usable
mutations_ref <- mutations %>%
  group_by(row.names(mutations)) %>%
  mutate(Change = extract_mut(Change,Location))

# Remove row.names columns
mutations_ref <- mutations_ref[-8]

# Removing the temp variable
rm(mutations, extract_mut)



########### Work with the Extracted mutations ###########

# Function searching through mutations_ref using df_isolate mutations.
# Takes a single row's cleaned mutations & the reference file as argument.
# Returns vector of mutation names from the reference data if found;
# if match not found, returns unchanged mutation notation.
# Called by "clean_mut()"
get_name <- function(muts, ref_muts){
  for (i in c(1:length(muts))){
    result = grep(paste("^", muts[i], sep=""), ref_muts$Change)
    if (length(result) > 0){ # If match found
      muts[i] = ref_muts$Designation[result]
    }
  }
  return (muts)
}

# Function to extract mutation info from a single row of df_isolate mutations.
# Takes a single row's raw mutations & the reference file as argument.
# Returns LIST of mutation names from the reference data if found;
# if match not found, cleaned mutation notation is returned instead.
# Calls: get_name(), to perform comparison to reference data
clean_mut <- function(mut, ref_muts){
  not_mut = c("haracter0", "Reference")
  if (mut %in% not_mut){ # If no mutation:
    newmut = list("Reference")
  } else{ # If mutation:
    newmut = gsub("[\"\\]", "", strsplit(mut, ", ")[[1]])
    newmut = list(get_name(newmut, ref_muts)) # Calls get_name()^
  }
  return (newmut) # Returns as list, so it can be stored in dataframe
}

# Dplyr code to rapidly process the entire dataset
df_isolate <- df_isolate %>%
  group_by(row.names(df_isolate)) %>%
  mutate(Mutations = I(clean_mut(Mutations, mutations_ref))) # calls clean_mut()

# Delete temp row.names column
df_isolate = df_isolate[-7]

```





